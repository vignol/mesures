20-Oct-2025 11:38:20.245 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat/11.0.1
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Nov 6 2024 19:08:24 UTC
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 11.0.1.0
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            6.14.0-29-generic
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/lib/jvm/java-21-openjdk-amd64
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           21.0.8+9-Ubuntu-0ubuntu124.04.1
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Ubuntu
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 11:38:20.249 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 11:38:20.259 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/conf/logging.properties
20-Oct-2025 11:38:20.259 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
20-Oct-2025 11:38:20.259 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=2048
20-Oct-2025 11:38:20.259 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dorg.apache.catalina.security.SecurityListener.UMASK=0027
20-Oct-2025 11:38:20.259 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.lang=ALL-UNNAMED
20-Oct-2025 11:38:20.259 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.io=ALL-UNNAMED
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util=ALL-UNNAMED
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util.concurrent=ALL-UNNAMED
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --enable-native-access=ALL-UNNAMED
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 11:38:20.260 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/temp
20-Oct-2025 11:38:20.262 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent The Apache Tomcat Native library which allows using OpenSSL was not found on the java.library.path: [/usr/java/packages/lib:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib]
20-Oct-2025 11:38:20.478 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler ["http-nio-8080"]
20-Oct-2025 11:38:20.500 INFO [main] org.apache.catalina.startup.Catalina.load Server initialization in [376] milliseconds
20-Oct-2025 11:38:20.542 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]
20-Oct-2025 11:38:20.543 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/11.0.1]
20-Oct-2025 11:38:20.554 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/serv.war]
20-Oct-2025 11:38:20.760 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/serv.war] has finished in [205] ms
20-Oct-2025 11:38:20.761 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/host-manager]
20-Oct-2025 11:38:20.792 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/host-manager] has finished in [31] ms
20-Oct-2025 11:38:20.793 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/docs]
20-Oct-2025 11:38:20.807 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/docs] has finished in [14] ms
20-Oct-2025 11:38:20.807 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/manager]
20-Oct-2025 11:38:20.827 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/manager] has finished in [20] ms
20-Oct-2025 11:38:20.827 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/examples]
20-Oct-2025 11:38:20.967 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/examples] has finished in [140] ms
20-Oct-2025 11:38:20.968 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/ROOT]
20-Oct-2025 11:38:20.978 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/ROOT] has finished in [10] ms
20-Oct-2025 11:38:20.981 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]
20-Oct-2025 11:38:20.988 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [485] milliseconds
20-Oct-2025 12:05:10.273 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat/11.0.1
20-Oct-2025 12:05:10.276 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Nov 6 2024 19:08:24 UTC
20-Oct-2025 12:05:10.276 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 11.0.1.0
20-Oct-2025 12:05:10.276 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux
20-Oct-2025 12:05:10.276 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            6.14.0-29-generic
20-Oct-2025 12:05:10.276 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64
20-Oct-2025 12:05:10.277 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/lib/jvm/java-21-openjdk-amd64
20-Oct-2025 12:05:10.277 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           21.0.8+9-Ubuntu-0ubuntu124.04.1
20-Oct-2025 12:05:10.277 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Ubuntu
20-Oct-2025 12:05:10.277 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:10.277 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:10.283 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/conf/logging.properties
20-Oct-2025 12:05:10.283 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=2048
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dorg.apache.catalina.security.SecurityListener.UMASK=0027
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.lang=ALL-UNNAMED
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.io=ALL-UNNAMED
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util=ALL-UNNAMED
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util.concurrent=ALL-UNNAMED
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --enable-native-access=ALL-UNNAMED
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:10.284 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/temp
20-Oct-2025 12:05:10.285 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent The Apache Tomcat Native library which allows using OpenSSL was not found on the java.library.path: [/usr/java/packages/lib:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib]
20-Oct-2025 12:05:10.518 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:10.567 SEVERE [main] org.apache.catalina.util.LifecycleBase.handleSubClassException Failed to initialize component [Connector["http-nio-8080"]]
	org.apache.catalina.LifecycleException: Protocol handler initialization failed
		at org.apache.catalina.connector.Connector.initInternal(Connector.java:1035)
		at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:122)
		at org.apache.catalina.core.StandardService.initInternal(StandardService.java:525)
		at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:122)
		at org.apache.catalina.core.StandardServer.initInternal(StandardServer.java:953)
		at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:122)
		at org.apache.catalina.startup.Catalina.load(Catalina.java:706)
		at org.apache.catalina.startup.Catalina.load(Catalina.java:729)
		at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
		at java.base/java.lang.reflect.Method.invoke(Method.java:580)
		at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:299)
		at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:469)
	Caused by: java.net.BindException: Address already in use
		at java.base/sun.nio.ch.Net.bind0(Native Method)
		at java.base/sun.nio.ch.Net.bind(Net.java:565)
		at java.base/sun.nio.ch.ServerSocketChannelImpl.netBind(ServerSocketChannelImpl.java:344)
		at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:301)
		at org.apache.tomcat.util.net.NioEndpoint.initServerSocket(NioEndpoint.java:240)
		at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:195)
		at org.apache.tomcat.util.net.AbstractEndpoint.bindWithCleanup(AbstractEndpoint.java:1472)
		at org.apache.tomcat.util.net.AbstractEndpoint.init(AbstractEndpoint.java:1485)
		at org.apache.coyote.AbstractProtocol.init(AbstractProtocol.java:633)
		at org.apache.coyote.http11.AbstractHttp11Protocol.init(AbstractHttp11Protocol.java:83)
		at org.apache.catalina.connector.Connector.initInternal(Connector.java:1033)
		... 11 more
20-Oct-2025 12:05:10.568 INFO [main] org.apache.catalina.startup.Catalina.load Server initialization in [407] milliseconds
20-Oct-2025 12:05:10.594 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]
20-Oct-2025 12:05:10.594 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/11.0.1]
20-Oct-2025 12:05:10.607 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/serv.war]
20-Oct-2025 12:05:10.820 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/serv.war] has finished in [212] ms
20-Oct-2025 12:05:10.820 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/host-manager]
20-Oct-2025 12:05:10.844 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/host-manager] has finished in [23] ms
20-Oct-2025 12:05:10.844 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/docs]
20-Oct-2025 12:05:10.857 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/docs] has finished in [13] ms
20-Oct-2025 12:05:10.858 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/manager]
20-Oct-2025 12:05:10.875 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/manager] has finished in [17] ms
20-Oct-2025 12:05:10.875 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/examples]
20-Oct-2025 12:05:11.027 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/examples] has finished in [152] ms
20-Oct-2025 12:05:11.027 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/ROOT]
20-Oct-2025 12:05:11.041 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/ROOT] has finished in [13] ms
20-Oct-2025 12:05:11.045 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [475] milliseconds
20-Oct-2025 12:05:11.048 SEVERE [main] org.apache.catalina.core.StandardServer.await Failed to create server shutdown socket on address [localhost] and port [8005] (base port [8005] and offset [0])
	java.net.BindException: Address already in use
		at java.base/sun.nio.ch.Net.bind0(Native Method)
		at java.base/sun.nio.ch.Net.bind(Net.java:565)
		at java.base/sun.nio.ch.Net.bind(Net.java:554)
		at java.base/sun.nio.ch.NioSocketImpl.bind(NioSocketImpl.java:636)
		at java.base/java.net.ServerSocket.bind(ServerSocket.java:391)
		at java.base/java.net.ServerSocket.<init>(ServerSocket.java:278)
		at org.apache.catalina.core.StandardServer.await(StandardServer.java:532)
		at org.apache.catalina.startup.Catalina.await(Catalina.java:845)
		at org.apache.catalina.startup.Catalina.start(Catalina.java:793)
		at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
		at java.base/java.lang.reflect.Method.invoke(Method.java:580)
		at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:342)
		at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:470)
20-Oct-2025 12:05:11.048 INFO [main] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:11.048 INFO [main] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]
20-Oct-2025 12:05:11.078 INFO [main] org.apache.coyote.AbstractProtocol.stop Stopping ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:11.079 INFO [main] org.apache.coyote.AbstractProtocol.destroy Destroying ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:39.420 INFO [main] org.apache.catalina.core.StandardServer.await A valid shutdown command was received via the shutdown port. Stopping the Server instance.
20-Oct-2025 12:05:39.421 INFO [main] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:39.422 INFO [main] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]
20-Oct-2025 12:05:39.445 INFO [main] org.apache.catalina.core.StandardWrapper.unload Waiting for [200] instance(s) to be deallocated for Servlet [pack.Serv]
20-Oct-2025 12:05:40.447 INFO [main] org.apache.catalina.core.StandardWrapper.unload Waiting for [200] instance(s) to be deallocated for Servlet [pack.Serv]
20-Oct-2025 12:05:41.449 INFO [main] org.apache.catalina.core.StandardWrapper.unload Waiting for [200] instance(s) to be deallocated for Servlet [pack.Serv]
20-Oct-2025 12:05:41.554 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.555 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.556 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.556 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.557 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.557 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.558 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.558 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.559 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.559 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.559 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.560 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.560 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.561 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.561 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.561 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.561 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.562 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.562 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.562 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.563 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.563 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.563 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.564 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.564 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.564 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.564 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.565 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.573 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.574 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.574 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.574 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.574 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.574 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.575 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.575 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.575 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.575 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.575 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.575 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.576 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.577 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.578 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.578 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.578 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.578 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.578 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.579 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.579 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.579 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.579 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.579 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.579 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.580 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.581 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.581 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.581 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.581 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.581 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.582 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.583 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.584 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.585 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.586 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.587 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.588 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.589 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.590 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.591 WARNING [main] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [serv] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation. Stack trace of request processing thread:[
 java.base/jdk.internal.misc.Unsafe.park(Native Method)
 java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:221)
 java.base/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1864)
 java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)
 java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)
 java.base/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1898)
 java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2072)
 java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:934)
 java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)
 pack.Serv.doGet(Serv.java:45)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:619)
 jakarta.servlet.http.HttpServlet.service(HttpServlet.java:716)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:130)
 org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
 org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:109)
 org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
 org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:79)
 org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
 org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
 org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
 org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:663)
 org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
 org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
 org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:395)
 org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
 org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)
 org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1746)
 org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
 org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148)
 org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
 org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
 java.base/java.lang.Thread.run(Thread.java:1583)]
20-Oct-2025 12:05:41.597 INFO [main] org.apache.coyote.AbstractProtocol.stop Stopping ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:41.676 INFO [main] org.apache.coyote.AbstractProtocol.destroy Destroying ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:54.378 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat/11.0.1
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Nov 6 2024 19:08:24 UTC
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 11.0.1.0
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            6.14.0-29-generic
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/lib/jvm/java-21-openjdk-amd64
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           21.0.8+9-Ubuntu-0ubuntu124.04.1
20-Oct-2025 12:05:54.381 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Ubuntu
20-Oct-2025 12:05:54.382 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:54.382 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:54.388 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/conf/logging.properties
20-Oct-2025 12:05:54.388 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=2048
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dorg.apache.catalina.security.SecurityListener.UMASK=0027
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.lang=ALL-UNNAMED
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.io=ALL-UNNAMED
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util=ALL-UNNAMED
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util.concurrent=ALL-UNNAMED
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --enable-native-access=ALL-UNNAMED
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1
20-Oct-2025 12:05:54.389 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/temp
20-Oct-2025 12:05:54.390 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent The Apache Tomcat Native library which allows using OpenSSL was not found on the java.library.path: [/usr/java/packages/lib:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib]
20-Oct-2025 12:05:54.584 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:54.598 INFO [main] org.apache.catalina.startup.Catalina.load Server initialization in [322] milliseconds
20-Oct-2025 12:05:54.625 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]
20-Oct-2025 12:05:54.626 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/11.0.1]
20-Oct-2025 12:05:54.636 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/serv.war]
20-Oct-2025 12:05:54.819 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/serv.war] has finished in [182] ms
20-Oct-2025 12:05:54.819 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/host-manager]
20-Oct-2025 12:05:54.844 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/host-manager] has finished in [25] ms
20-Oct-2025 12:05:54.844 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/docs]
20-Oct-2025 12:05:54.857 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/docs] has finished in [13] ms
20-Oct-2025 12:05:54.857 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/manager]
20-Oct-2025 12:05:54.872 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/manager] has finished in [15] ms
20-Oct-2025 12:05:54.872 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/examples]
20-Oct-2025 12:05:55.017 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/examples] has finished in [145] ms
20-Oct-2025 12:05:55.018 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/ROOT]
20-Oct-2025 12:05:55.032 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/home/vignol-bande/Downloads/mesures/apache-tomcat-11.0.1/webapps/ROOT] has finished in [14] ms
20-Oct-2025 12:05:55.036 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]
20-Oct-2025 12:05:55.044 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [444] milliseconds
